import { NextRequest, NextResponse } from "next/server";
import { GenerateContentResponse, GoogleGenAI } from "@google/genai";
import { auth } from "@clerk/nextjs/server";
import {
  enhancePromptWithContext,
  rewriteQueryWithOpenAI,
} from "@/lib/ai/ai_service";

// Initialize APIs
const genAI = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY || "" });

export async function POST(request: NextRequest) {
  // Check authentication
  const { userId } = await auth();
  if (!userId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const body = await request.json();
    const {
      prompt,
      config = {
        videoTitle: "",
        primaryColor: "#DC2626",
        secondaryColor: "#2563EB",
        defaultImage: "",
        defaultImagePreview: "",
        niche: "education",
        size: "16:9",
      },
      imageData,
      imageMimeType,
    } = body;

    // Validate required fields
    if (!prompt || prompt.trim().length < 3) {
      return NextResponse.json(
        { error: "Prompt must be at least 3 characters long" },
        { status: 400 }
      );
    }

    // Step 1: Rewrite the query using OpenAI with context
    const rewrittenPrompt = await rewriteQueryWithOpenAI(prompt, config);

    // Step 2: Enhance the prompt with contextual details
    const enhancedPrompt = await enhancePromptWithContext(
      rewrittenPrompt,
      config
    );

    // Step 3: Create the compact and effective final prompt
    const finalPrompt = createThumbnailPrompt({
      prompt: enhancedPrompt,
      config,
    });

    // Step 4: Prepare contents for Gemini API - FIXED
    const hasBaseImage = !!imageData || !!config.defaultImagePreview;

    // Create contents array according to the documentation
    const contents: any[] = [];

    if (hasBaseImage) {
      let base64Data;
      let mimeType = "image/png"; // Default MIME type

      if (imageData) {
        base64Data = imageData;
        mimeType = imageMimeType || "image/png";
      } else if (config.defaultImagePreview) {
        if (config.defaultImagePreview.startsWith("data:")) {
          const parts = config.defaultImagePreview.split(",");
          const mimeMatch = parts[0].match(/data:([^;]+)/);
          if (mimeMatch) mimeType = mimeMatch[1];
          base64Data = parts[1];
        } else {
          // Fetch and convert URL to base64
          const response = await fetch(config.defaultImagePreview);
          const blob = await response.blob();
          mimeType = blob.type;
          const arrayBuffer = await blob.arrayBuffer();
          base64Data = Buffer.from(arrayBuffer).toString("base64");
        }
      }

      // For image editing: add text first, then image(s)
      contents.push(
        { text: finalPrompt },
        {
          inlineData: {
            mimeType,
            data: base64Data,
          },
        }
      );
    } else {
      // For text-to-image: just the prompt
      contents.push(finalPrompt);
    }

    // Step 5: Generate thumbnail using Gemini - FIXED API CALL
    const result = await genAI.models.generateContent({
      model: "gemini-2.5-flash-image-preview",
      contents: contents, // Pass the contents array directly
    });

    const response = result as GenerateContentResponse;

    // Extract the generated image data - FIXED ACCESS PATTERN
    const generatedPart = response?.candidates?.[0]?.content?.parts?.find(
      (part: any) => part.inlineData
    );

    if (generatedPart && generatedPart.inlineData) {
      return NextResponse.json({
        success: true,
        imageData: generatedPart.inlineData.data,
        prompt: finalPrompt,
        originalTitle: prompt,
        rewrittenTitle: rewrittenPrompt,
        enhancedPrompt: enhancedPrompt,
      });
    }

    // Handle cases where no image is generated, potentially with safety feedback
    const safetyFeedback = response.candidates?.[0]?.finishReason;
    const errorMessage =
      safetyFeedback === "SAFETY"
        ? "Image generation was blocked due to safety policies."
        : "No image was generated by the model.";

    return NextResponse.json(
      { error: errorMessage, details: response.promptFeedback || null },
      { status: 500 }
    );
  } catch (error) {
    console.error("Failed to generate thumbnail:", error);
    return NextResponse.json(
      {
        error: "Failed to generate thumbnail",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}

function createThumbnailPrompt({
  prompt,
  config,
}: {
  prompt: string;
  config: {
    videoTitle: string;
    primaryColor: string;
    secondaryColor: string;
    niche: string;
    size: string;
    defaultImagePreview?: string;
  };
}) {
  const nicheStyles: {
    [key: string]: { style: string; lighting: string; textStyle: string };
  } = {
    gaming: {
      style: "dynamic, vibrant, with bold text and energetic graphics",
      lighting: "dramatic, neon, or RGB lighting",
      textStyle: "bold, futuristic, or grunge-style font",
    },
    business: {
      style:
        "professional, clean, and minimalist with sophisticated typography",
      lighting: "bright, professional studio lighting",
      textStyle: "a clean, modern sans-serif font",
    },
    education: {
      style: "clear, approachable, and informative with easy-to-read text",
      lighting: "bright and natural lighting",
      textStyle: "a clear, readable serif or sans-serif font",
    },
    entertainment: {
      style: "eye-catching, creative, and highly stylized",
      lighting: "cinematic or colorful, dramatic lighting",
      textStyle: "a playful, bold, and expressive font",
    },
    technology: {
      style: "modern, sleek, and futuristic with digital aesthetics",
      lighting: "cool-toned LED or cinematic lighting",
      textStyle: "a sleek, minimalist, and modern font",
    },
    lifestyle: {
      style: "warm, authentic, and inviting with a natural feel",
      lighting: "soft, natural, or golden hour lighting",
      textStyle: "an elegant, script, or friendly sans-serif font",
    },
  };

  const selectedNiche = nicheStyles[config.niche] || nicheStyles.entertainment;

  if (
    config.defaultImagePreview ||
    (arguments[0].config && arguments[0].config.imageData)
  ) {
    // Prompt for enhancing an existing image
    return `
      IMPORTANT: Your task is to modify and enhance the provided reference image to turn it into a professional thumbnail. Do NOT generate a new image from scratch.

      Your goal is to apply the following enhancements based on this creative description: "${prompt}".

      Key modifications:
      1.  **Style & Mood:** Adapt the image to a ${selectedNiche.style} style suitable for the "${config.niche}" niche.
      2.  **Color & Lighting:** Greatly enhance the colors. The primary color should be ${config.primaryColor} with ${config.secondaryColor} as an accent. Adjust the lighting to be more ${selectedNiche.lighting}.
      3.  **Text:** If the description calls for it, add the video title "${config.videoTitle}" using ${selectedNiche.textStyle} that is highly readable.
      4.  **Composition:** Keep the main subject of the original image but improve the overall composition for maximum click-through appeal.

      Crucially, the final image must have a ${config.size} aspect ratio. The result should look like a professionally upgraded version of the original image.
    `;
  } else {
    // Prompt for generating a new image from scratch
    return `
      Create a single, professional, high-impact thumbnail for a video titled "${config.videoTitle}".

      The thumbnail must visually represent the following detailed description: "${prompt}".

      **Core requirements:**
      - **Niche & Style:** The overall aesthetic must be ${selectedNiche.style}, perfect for the "${config.niche}" niche.
      - **Color Palette:** The design must prominently feature ${config.primaryColor} as the primary color and ${config.secondaryColor} as an accent color. Ensure high contrast for visibility.
      - **Typography:** If text is included, it should be highly readable, using ${selectedNiche.textStyle}.
      - **Quality:** Generate a studio-quality, ultra-high-resolution image that is clean, sharp, and designed to maximize click-through rates.

      Crucially, the final image must have a ${config.size} aspect ratio.
    `;
  }
}
